---
title: 텍스트 분석을 통한 프로듀스X101 데뷔조 예측4 [시각화]
author: JDW
date: '2019-12-19'
slug: producex5
categories:
  - 데이터분석
tags:
  - R
---
```{r, message=FALSE, include=FALSE}
library(tidyverse)
library(lubridate)
library(data.table)
library(knitr)
library(gtools)
library(widgetframe)

dir <- 'C:/Users/JDW/Desktop/my_cloud/OneDrive/R/producex/data'
filelist <- list.files(dir)
filelist <- mixedsort(filelist, decreasing = T)
pxdata <- data.frame()
temp <- NULL

for(file in filelist){
    if(str_sub(file, -3, -1) == 'csv'){
        temp <- fread(paste(dir, file, sep = '/'), header = T, stringsAsFactors = F)
        temp <- temp %>% select(p_title, p_time)
        pxdata <- rbind(pxdata, temp)
        
        rm(temp)
    }else{
        next
    }

}

pxdata <- pxdata %>% mutate(p_ymd = as.Date(p_time), 
                            p_wday = lubridate::wday(as.Date(p_time), label = T),
                            p_weeknum = week(as.Date(p_time) - 5) - 17
                            )

boylist <- readLines('C:/Users/JDW/Desktop/my_cloud/OneDrive/R/producex/final_boylist.txt')

```

![](/post/2019-12-19-producex5_files/final.jpg){width=80%}
<br>

&nbsp;이제 분석의 마지막 작업으로 지금까지 전처리한 데이터를 기반으로 어느 연습생의 언급량이 높았었는지를 직접 확인해 볼 시간입니다. 데이터 크롤링부터 이전 시간에 진행한 EDA까지 다소 짧은 분량은 아니었는데요. 이번 시각화를 통해서 분석을 마무리를 지어볼까 합니다.

<br>

# 데이터 시각화 
 
&nbsp; 지금까지 수집한 데이터는 실제로 방송을 시청하는 시청자들이 게시판에 작성했던 게시물들의 제목들(`p_title`) 입니다. 즉, 방송을 보고 투표를 할 확률이 높은 시청자들의 의견이 담긴 텍스트인데요. 처음 분석을 기획하였을 당시 저는 먼저 한가지 가정을 했었습니다. 그건 바로 언급량이 높으면 높을수록 그만큼 인기도 많을 것 이였는데요. 사람들 입에서 회자가 많이 된다는 것은 그만큼 관심과 인기가 있다는 의미이고, 투표량도 그것과 상관이 있을것이다라고 가정하였습니다. 

<br> 

## 범위 설정
<br> 
&nbsp; 프로듀스X101은 101명의 연습생들이 경쟁을 펼치고, 시청자들의 투표를 통해서 최종 11명의 아이돌 멤버를 선발한다는 컨셉의 방송인데요. 마지막 방송날에 인기가 높았던 20명의 연습생들이 생방송 무대에서 경합을 펼쳤습니다. 마지막 방송까지 살아남은 최종 20명을 대상으로 분석을 진행해 보도록 하겠습니다. 

미리 마지막 생방송에 진출한 스무명의 연습생 이름을 `final_boylist.txt` 파일에 저장해 두었었고, 이를 불러오겠습니다. 

```{r, eval = FALSE}
boylist <- readLines('./final_boylist.txt')
boylist
```

```{r, echo=FALSE}
boylist
```

&nbsp; 언급량은 연습생별로 연습생이 언급된 게시물들의 갯수가 몇개인지를 세어보는 방식으로 집계할 것입니다. 그런데 게시물들의 특성상 연습생의 fullname을 적는 경우보다 name만 적는 경우가 많이 있었기에 먼저 호출한 `boylist`에서 이름만 추출하겠습니다. 

```{r}
boylist2 <- str_sub(boylist, -2, -1) # 뒤에서 두번째 글자부터 뒤에서 첫번째 글자까지만을 저장 
boylist2
```

그런다음 for문을 통해 연습생별로 언급량을 집계해 보겠습니다. 

<br>

## 언급량 집계

```{r}
boys <- NULL
for(i in 1:length(boylist2)){
    boys[i] <- nrow(pxdata[grep(boylist2[i], pxdata$p_title), ]) #연습생별 언급게시글 수를 boys 리스트에 저장 
}

boys_comment <- data.frame(cbind(boylist, boys), stringsAsFactors = F) # 연습생 - 연습생 언급게시글 수 데이터프레임화 
boys_comment$boys <- as.numeric(boys_comment$boys) # 숫자형으로 변환 

str(boys_comment)
```

이를 시각화하여 바로 알아보도록 하겠습니다. 

<br>

## 시각화


### Barchart
```{r, out.width="1000px"}
boys_comment %>% 
    ggplot(aes(x = boylist, y = boys)) + 
    geom_col() + 
    geom_text(aes(label = boys), vjust = -.5, size = 2) + 
    theme(axis.text.x = element_text(angle = 45)) 
```

```{r, out.width="1000px"}
boys_comment %>% 
    ggplot(aes(x = reorder(boylist, -boys), y = boys)) + 
    geom_col() + 
    geom_text(aes(label = boys), vjust = -.5, size = 2) + 
    theme(axis.text.x = element_text(angle = 45)) 

```


시각화를 진행한 결과 **김우석**, **조승연**, **김민규**, **구정모**, **이은상**, **김요한**, **남도현**, **송형준**, **강민희**, **한승우** , **이진혁** 순으로 언급량이 많은것을 확인 할 수 있었습니다. 

하지만 이것은 전체기간을(06/01 ~ 07/19) 대상으로 집계한 언급량이기 때문에 연습생들의 시간에 따른 언급량의 변화는 찾아 볼 수가 없네요. 방송이 진행되면서 멋진 무대를 소화해 낸 연습생은 순위가 올라간 경우도 있었고, 반대로 다른 여러 요인들로 인해 인기가 하락한 경우도 종종 볼 수 있었습니다. 

그렇다면 이번에는 에피소드별로 연습생들의 언급량이 어떻게 변화했는지를 확인해 보도록 하겠습니다. 

<br>

### Barchart(Split by episode)

```{r}
boyname <- NULL
temp <- NULL
total <- NULL
for(i in 1:7){
    assign(paste0('episode_', i + 4), data.frame()) # 빈 객체 생성
    assign(paste0('episode_', i + 4), pxdata %>% filter(p_weeknum == i + 4)) # 회차별로 데이터 나누기
    boyname <- NULL
    temp <- NULL
    for(x in 1:length(boylist2)){
        boyname[x] <- nrow(get(paste0('episode_', i + 4))[grep(boylist2[x], get(paste0('episode_', i + 4))$p_title), ])
    }
    temp <- as.data.frame(cbind(boylist2, boyname))
    temp$weeknum <- i + 4
    total <- rbind(total, temp)

}
```

`assign()` 함수는 변수를 만들때 사용하는 함수입니다. for문 내부에서는 할당연산자인 `=` 혹은 `<-` 를 사용할수가 없는데요, for문 내에서 특정한 변수를 생성해야 할 경우가 발생할 수 있습니다. 그럴경우 `assign('변수명', '변수')`의 형태를 통해 변수를 만드실 수 있습니다. 

코드를 잠깐 해석하자면 `assign()` 함수를 통해 `episode_5` ~ `episode_11` 까지의 변수를 생성하고, 각각의 변수에다가 변수 이름에 맞는 데이터들을 분할하여 넣어주었습니다. 그런다음 다시 내부의 for문을 통해 각 에피소드별 연습생들의 언급량을 구하였고(`boyname` 변수), 이를 연습생의 이름칼럼과 합친 `temp`라는 이름의 데이터 프레임으로 생성해 주었습니다. 그리고 최종적으로 `rbind()` 함수를 통해 `total` 이란 변수에 접합을 해주었습니다. 

말로 설명하자니 꽤나 추상적이군요 이번에는 `total` 변수 직접 확인해 보겠습니다.  

```{r}
frameWidget(DT::datatable(total))
```

이렇게 에피소드별, 연습생별로 나누어진 데이터를 Barchart를 통해 시각화 해보겠습니다. 

```{r, out.width="1000px"}
colnames(total) <- c('boyname', 'mention', 'weeknum')
total$mention <- as.numeric(as.character(total$mention))

total %>% 
    ggplot(aes(x = as.factor(weeknum), y = mention)) + 
    geom_col() + 
    geom_text(aes(label = mention), vjust = -1, size = 2) + 
    facet_wrap( ~ boyname) + 
    labs(x = 'episode', y = 'mention')
```

확실히 시간에 따른(에피소드) 연습생의 언급량이 어떻게 변화하였는지가 파악이 되는군요. 그렇지만 언급량 순으로 정렬이 안돼있어서 직관적으로 파악하기가 어렵습니다. 한번 11주차 방송 기간을 기준으로 연습생의 언급도를 재정렬해 보겠습니다.

<br>

### Barchart(Split by episode and reordered)

```{r, out.width="1000px"}
pxlevel <- total %>%
    filter(weeknum == 11) %>%
    arrange(desc(mention)) %>%
    select(boyname) %>%
    as.list()

pxlevel <- melt(pxlevel)
pxlevel <- pxlevel$value
pxlevel <- as.character(pxlevel)
total_ordered <- arrange(transform(total, boyname = factor(boyname, levels = pxlevel)), boyname)

total_ordered %>% ggplot(aes(x = as.factor(weeknum), y = mention, group = boyname)) +
    geom_col() +
    facet_wrap( ~ boyname) +
    geom_text(aes(label = mention), vjust = -1, size = 2) + 
    labs(title = '[PRODUCEX101] 회차별 연습생 언급량 변화 추이', 
        subtitle = '"ep.11" 기준 정렬',
        x = 'episode', y = 'mention')
```

11회차를 기준으로는 **조승연**, **구정모**, **김우석**, **김민규**, **남도현**, **한승우**, **이은상**, **강민희**, **이진혁**, **김요한**, **송형준** 순으로 언급된 것을 볼 수 있습니다. 실제로 데뷔한 연습생들과 비교해 보니 전체 11명중 8명이 속하는군요 (물론 잘못된 투표였다는 발표가 있었지만요...) 하지만 온라인 커뮤니티에서 실제 사람들이 누구를 많이 얘기하고, 누구를 상대적으로 적게 얘기하는지를 객관적으로 측정할 수 있는 분석이였습니다.  

이제 정말 마지막으로 Bump chart를 제작하여 연습생들의 언급도가 어떻게 변화하였는지를 확인해 보도록 하겠습니다. 

<br>

### Bump chart

![](/post/2019-12-19-producex5_files/Bump-Chart-unnamed-chunk-7-1.png){width=50%}

<center>
<em> Bump chart </em>
</center>


Bump chart는 순위가 있는 값들을 시각화하는데 사용이 되는 차트인데요. 위와 같이 순위의 변화를 관찰할때 유용하게 사용되는 차트입니다.  

```{r, message=FALSE, out.width="1000px"}
library(plotly)

# data setting
total_ranking <- total %>%
    group_by(weeknum) %>%
    arrange(-mention) %>%
    mutate(ranking = row_number()) %>%
    as.data.frame()

# theme
my_theme <- function() { 

    # Colors
    color.background = "white"
    color.text = "#22211d"

    # Begin construction of chart
    theme_bw(base_size=15) +

        # Format background colors
        theme(panel.background = element_rect(fill=color.background, color=color.background)) +
        theme(plot.background  = element_rect(fill=color.background, color=color.background)) +
        theme(panel.border     = element_rect(color=color.background)) +
        theme(strip.background = element_rect(fill=color.background, color=color.background)) +

        # Format the grid
        theme(panel.grid.major.y = element_blank()) +
        theme(panel.grid.minor.y = element_blank()) +
        theme(axis.ticks       = element_blank()) +

        # Format the legend
        # theme(legend.position = "none") +

        # Format title and axis labels
        theme(plot.title       = element_text(color=color.text, size=20, face = "bold")) +
        theme(axis.title.x     = element_text(size=14, color="black", face = "bold")) +
        theme(axis.title.y     = element_text(size=14, color="black", face = "bold", vjust=1.25)) +
        theme(axis.text.x      = element_text(size=10, vjust=0.5, hjust=0.5, color = color.text)) +
        theme(axis.text.y      = element_text(size=10, color = color.text)) +
        theme(strip.text       = element_text(face = "bold")) +

        # Plot margins
        theme(plot.margin = unit(c(0.35, 0.2, 0.3, 0.35), "cm"))
}

# Visualizing
total_ranking %>%
    ggplot(aes(x = weeknum, y = ranking, group = boyname)) +
    geom_line(aes(color = boyname, alpha = 1), size = 2) +
    geom_point(aes(color = boyname, alpha = 1), size = 4) +
    geom_point(color ='#FFFFFF', size = 1) +
    scale_x_continuous(breaks = 5: 11, minor_breaks = 5:11, expand = c(.05, .05)) +
    scale_y_reverse(breaks = 1:20) +
    geom_text(data = total_ranking %>% filter(weeknum == 5),
              aes(label = boyname, x = 4.5), hjust = 2, fontface = 'bold', color = '#888888', size = 5) +
    geom_text(data = total_ranking %>% filter(weeknum == 11),
              aes(label = boyname, x = 11.5), hjust = 2, fontface = 'bold', color = '#888888', size = 5) +
    theme(legend.position = 'none') +
    labs(title = '[PRODUCEX101 GALLARY] WEEKLY BUMPCHART',
         subtitle = 'separated by episode',
         x = 'episode', y = 'ranking', alpha = "", color = "") +
    my_theme() -> p

p1 <- ggplotly(p)

frameWidget(p1)

```

<br>
<center>
<em> 이름을 더블클릭하면 추세를 명확하게 확인할 수 있습니다. </em>
</center>

<br>

Bumpchart는 특별히 `plotly`를 활용하여 반응형 차트를 제작해 보았습니다. 마우스액션을 통해 좀더 세분화되게 차트를 탐색해 볼 수 있습니다. 

<br>

***

<br>
지금까지 데이터를 수집부터, 시각화 분석까지의 전반적인 과정들을 한번 훝어보았습니다. 예전에 취미삼아 혼자서만 분석하고 묵혀만 두었던 프로젝트였는데 블로그를 구축하고, 많은 분들께 공유할 수 있게 되어서 감회가 새롭네요. R 유저로서 `blogdown` 패키지로 한번 블로그를 만들어 보고 싶었는데 올해가 넘어가기 전에 그 일을 끝마칠수 있어서 개인적으로 뿌듯합니다. 


처음 작성한 글이라 미흡한 글이긴 하지만 도움이나 흥미가 있었기를 바라며 이만 마무리 짓도록 하겠습니다. 지금까지 긴글 읽어주셔서 감사합니다.

<br>













