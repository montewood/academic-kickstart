---
title: 텍스트분석을 통한 프로듀스X101 데뷔조 예측1 [데이터수집]
author: JDW
date: '2019-12-12'
slug: producex2
categories:
  - 데이터분석
tags:
  - R
output:
  blogdown::html_page:
    toc: true
---


<div id="TOC">
<ul>
<li><a href="#데이터-수집">데이터 수집</a></li>
<li><a href="#code">code</a></li>
</ul>
</div>

<div id="데이터-수집" class="section level1">
<h1>데이터 수집</h1>
<p>데이터 분석을 위해 가장 먼저 해야 할 일은 분석의 대상이 될 데이터를 확보 하는 일 입니다.</p>
<p>이전 글에서 말했다시피 이번 파트에서 진행할 것은 데이터 크롤링에 관한 전반적인 것들 입니다.</p>
<p>프로듀스X101 관련 모든 커뮤니티의 글들을 수집하는것은 물리적으로 불가능에 가깝기 때문에 해당방송과 관련된 커뮤니티중 가장 규모가 큰 한곳을 선정하여 데이터 수집을 진행하였습니다.
<br>
<br></p>
<img src="/post/2019-12-12-producex2_files/dc_producexgallery.png" style="width:80.0%" />
<center>
<em>디시인사이드 프로듀스x101 갤러리</em>
</center>
<p><br></p>
<p>해당 커뮤니티는 방송이 인기를 끌었던 시점에 하루에 대략 4만건의 게시물이 올라왔었는데요.
한참 방송이 진행중이던 06/01 부터 마지막 생방송날인 07/19 까지의 데이터를 수집하였었습니다.
<br></p>
<p>웹 데이터 수집을 위한 여러 방법이 있지만 R 에서 웹페이지를 크롤링할때 보편적으로 사용하는 <code>rvest</code> 패키지를 활용하여 크롤링을 진행하였습니다.
<br></p>
<p>아래는 크롤링 코드 입니다.</p>
</div>
<div id="code" class="section level1">
<h1>code</h1>
<pre class="r"><code># 저장 폴더 설정 
setwd(&#39;./PRODUCEX/CRAWLING DATA&#39;)

library(rvest)
library(dplyr)
library(lubridate)
library(stringr)</code></pre>
<p><br></p>
<p>먼저 크롤링한 데이터를 저장할 폴더와 필요한 패키지들을 호출 합니다.</p>
<p><br></p>
<pre class="r"><code>basic_url &lt;- &#39;https://gall.dcinside.com/board/lists/?id=producex&amp;page=&#39;

# 주소설정 ----

urls &lt;- NULL
for(x in 0:599){
    urls[x + 1] &lt;- paste0(basic_url, x + 1)
}</code></pre>
<p><br></p>
<p>웹 데이터를 크롤링해 오는데엔 두가지 방식이 있습니다. 바로 GET 방식과 POST방식인데요. <br>
GET 방식은 웹페이지의 URL주소를 기반으로 데이터를 가저오는 형식입니다. 즉, 특정한 웹페이지의 주소를 서버측에 요청하면 서버는 요청에 대한 응답으로 웹페이지 URL의 정보를 클라이언트(사용자)에게 보내주는 것입니다. 우리가 인터넷을 사용할때 주소창에 URL주소를 입력하고 엔터를 누를때 웹페이지가 변경되는 것을 생각하시면 됩니다.</p>
<p>R에서는 이러한 동작의 수행을 위해서 <code>rvest</code> 패키지를 보편적으로 사용합니다.</p>
<p><br></p>
<p>웹페이지 주소를 기반으로 정보를 가져오기 때문에 정보를 가져올 웹페이지의 주소를 for문을 통해서 만들어 줍니다.</p>
<p>해당 코드를 돌리면 다음과 같은 결과값이 나옵니다.</p>
<pre><code>## [1] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=1&quot;
## [2] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=2&quot;
## [3] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=3&quot;
## [4] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=4&quot;
## [5] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=5&quot;
## [6] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=6&quot;</code></pre>
<pre><code>## [1] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=595&quot;
## [2] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=596&quot;
## [3] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=597&quot;
## [4] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=598&quot;
## [5] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=599&quot;
## [6] &quot;https://gall.dcinside.com/board/lists/?id=producex&amp;page=600&quot;</code></pre>
<p><br></p>
<p>for문을 통해 1페이지부터 600페이지까지 총 600개의 웹페이지 주소가 생성되었네요.</p>
<p>만들어진 주소들을 기반으로 크롤링을 진행합니다. 먼저 크롤링 정보를 담을 빈객체들을 생성합니다.</p>
<p><br></p>
<pre class="r"><code># 크롤링 ----

html1 &lt;- NULL
p_title &lt;- NULL
p_writer &lt;- NULL
p_writer_id &lt;- NULL
p_time &lt;- NULL
p_count &lt;- NULL
p_recommend &lt;- NULL
dc &lt;- NULL</code></pre>
<p><br></p>
<p>본격적으로 for문을 통해 데이터를 페이지순으로 순차적으로 가져옵니다.</p>
<p><br></p>
<pre class="r"><code>for(url in urls){
            html1 &lt;- read_html(url)
            p_title &lt;- c(p_title, html1 %&gt;%
                             html_nodes(&#39;.ub-content.us-post&#39;) %&gt;%
                             html_nodes(&#39;.gall_tit.ub-word&#39;) %&gt;%
                             html_node(&#39;a&#39;) %&gt;%
                             html_text())
            p_writer &lt;- c(p_writer, html1 %&gt;%
                              html_nodes(&#39;.ub-content.us-post&#39;) %&gt;%
                              html_nodes(&#39;.gall_writer.ub-writer&#39;) %&gt;%
                              html_attr(&#39;data-nick&#39;))
            p_writer_id &lt;- c(p_writer_id, html1 %&gt;%
                                 html_nodes(&#39;.ub-content.us-post&#39;) %&gt;%
                                 html_nodes(&#39;.gall_writer.ub-writer&#39;) %&gt;%
                                 html_attr(&#39;data-uid&#39;))
            p_time &lt;- c(p_time, html1 %&gt;%
                            html_nodes(&#39;.ub-content.us-post&#39;) %&gt;%
                            html_nodes(&#39;.gall_date&#39;) %&gt;%
                            html_attr(&#39;title&#39;))
            p_count &lt;- c(p_count, html1 %&gt;%
                             html_nodes(&#39;.ub-content.us-post&#39;) %&gt;%
                             html_nodes(&#39;.gall_count&#39;) %&gt;%
                             html_text())
            p_recommend &lt;- c(p_recommend, html1 %&gt;%
                                 html_nodes(&#39;.ub-content.us-post&#39;) %&gt;%
                                 html_nodes(&#39;.gall_recommend&#39;) %&gt;%
                                 html_text())

}</code></pre>
<p><br></p>
<p>해당 for문을 돌릴시 R은 맨 처음 만들었던 주소들 즉, urls 객체에 담긴 주소값을 받아서 서버에게 순차적으로 주소에 대한 정보를 요청하게 됩니다. 그리고 for문 내부에 있는 코드를 수행하는데요, 각각의 객체에 해당하는 값들을(p_title, p_time 등등..) 파싱합니다. 모든 코드를 수행하면 for문은 다음 주소를 요청하여 처음 코드부터 다시 파싱을 진행하게 됩니다.</p>
<p><br></p>
<pre class="r"><code># 데이터 프레임화 
dc &lt;- data.frame(p_title, p_writer, p_writer_id, p_time, p_count, p_recommend)

# 날짜조정 ----
dc$p_time &lt;- ymd_hms(dc$p_time)
dc &lt;- dc[day(dc$p_time) == day(today()-1), ]</code></pre>
<p><br></p>
<p>for문을 통해 수집한 각각의 객체 데이터들을 ‘dc’ 라는 이름의 데이터프레임에 담아줍니다. 시간을 다루는 <code>lubridate</code> 패키지의 <code>ymd_hms()</code>함수를 이용하여 글 작성 시간을 의미하는 <code>p_time</code> 데이터를 시간 데이터로 변경해 줍니다.</p>
<p>저는 이 코드를 <code>taskscheduleR</code> 패키지를 활용하여 매일 자정무렵 자동으로 돌아가게끔 설정 하였었는데요, 데이터를 매일 수집하는 것이다 보니 오직 전날에 작성된 글들만을 저장하기 위해서 <code>dc &lt;- dc[day(dc$p_time) == day(today()-1), ]</code> 필터링 코드를 만들었습니다. 코드를 짧막하게 설명하자면 글 작성 시간을 의미하는 <code>dc$p_time</code> 이 수집하는 날 바로 하루 전 <code>today() - 1</code> 의 값과 동일한 값만을 dc객체로 새로이 담아낸 것입니다.</p>
<table>
<thead>
<tr class="header">
<th align="right">V1</th>
<th align="left">p_title</th>
<th align="left">p_writer</th>
<th align="left">p_writer_id</th>
<th align="left">p_time</th>
<th align="right">p_count</th>
<th align="right">p_recommend</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">42448</td>
<td align="left">???</td>
<td align="left">ㅇㅇ</td>
<td align="left"></td>
<td align="left">2019-06-01 00:00:02</td>
<td align="right">5</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">42449</td>
<td align="left">시즌4 비센이 잇긴 하냐</td>
<td align="left">ㅇㅇ</td>
<td align="left"></td>
<td align="left">2019-06-01 00:00:01</td>
<td align="right">11</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">42450</td>
<td align="left">아아아아앙 민희야어아아아앙</td>
<td align="left">ㅇㅇ</td>
<td align="left"></td>
<td align="left">2019-06-01 00:00:01</td>
<td align="right">4</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">42451</td>
<td align="left">아악 유리옵ㅠㅠㅠㅠㅠㅠ</td>
<td align="left">유리는유리다</td>
<td align="left">yuri1228</td>
<td align="left">2019-06-01 00:00:00</td>
<td align="right">40</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">42452</td>
<td align="left">김민규 그와중에 또 핑크입은거 실화냐</td>
<td align="left">ㅇㅇ</td>
<td align="left">adkljf</td>
<td align="left">2019-06-01 00:00:00</td>
<td align="right">36</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">42453</td>
<td align="left">진짜 한남들 자적자 어뜩하냐</td>
<td align="left">ㅇㅇ</td>
<td align="left"></td>
<td align="left">2019-06-01 00:00:00</td>
<td align="right">27</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<center>
<em>크롤링을 마친 데이터의 구조 </em>
</center>
<p><br></p>
<pre class="r"><code># 파일저장 ----
write.csv(dc, paste0(ymd(today()-1), &quot;.csv&quot;))</code></pre>
<p><br></p>
<p>마지막으로 필터링까지 완료된 데이터를 csv파일로 저장합니다.</p>
</div>
